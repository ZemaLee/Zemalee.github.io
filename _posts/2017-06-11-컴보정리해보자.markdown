---
layout: entry
title: "컴퓨터보안 시험용 정리"
author: 이제언
date: 2017-06-11 17:05 +0900
tags: 컴퓨터보안, 보안, 기말고사
comments: true
--- 
* table of contents
{:toc}

# CH10.1 Key Management other PKC

## RSA

### Review

일반적으로 암호화 할 때, sender, receiver가 같은 key를 공유했었다.

이렇게 되면, 두 사람이 key를 분배하는 과정에서 n명이 각각 서로 카톡방(?)을 가져야 하기 때문에 **nC2** 개 만큼 key가 필요했다.

그래서, **공개키 알고리즘**을 사용하기로 한다.



1. 두 소수 p, q를 선정한다.  
2. p, q를 통해 n = p x q라는 값을 갖게된다.  
3. phi(n) = (p-1) x (q-1) 값을 갖는다.  
4. gcd( e, phi(n) ) = 1인 e 값을 선정하여 공개키로 설정한다.  
5. d x e = 1 (mod phi(n))인 d를 구한다.

위 과정을 통해 PU = {e, n}, PR = {p, q, d}가 설정된다.

### 메세지 암호화, 복호화  
CipherText = Message^{e} mod n.  
공개키 e, n을 통해 아무 메시지나 암호화해서 보낼 수 있다.  

Message = CiperText^{d} mod n.  
비밀키 d를 통해 비밀 메시지를 풀 수 있다.



## 키 분배(관리)

키 분배(관리)에는 4가지 방법이 있다.

### Public Announcement  
그냥 다른 사람들에게 자신의 key를 알리는 방법이다.  
위조에 취약함.(ex. 저 제언인데요, 100만원만 빌려주세요^^)

### Public Available Directory  
게시판 같은 열린 공간에 자신의 공개키를 올리는 방법이다.  
이 방법은 홈페이지가 공격당하면 GG...

### Public-key Authority  
Public-key Authority(기관)이 공개키를 관리해주는 방식이다.  
A와 B가 통신하기 위해 아래의 과정을 거쳐야한다.

1. A가 기관에게 B의 공개키를 요구한다.  
(A->PA) Request || TimeStamp1  
2. 기관이 A에게 공개키를 서명해서 준다.  
(PA->A) E(PR_{auth} [ PU_{b} || Request || TimeStamp1 ])

3. A가 B의 공개키로 자신의 아이디와 Nonce를 실어 보낸다.  
(A->B) E(PU_{b}, [ID_{A} || Nonce1])

4. B도 기관에게 1, 2의 과정을 거쳐 A의 공개키를 얻는다.(식 생략)

5. B가 A의 공개키로 받은 Nonce와 새로운 Nonce를 생성하여 보낸다.
(B->A) E(PU_{a}, [N1 || N2])  
이 과정에서 B의 공개키로 암호화 된 N1을 해독하고 다시 보내주는 과정을 통해 **상호 인증**이 된다.

6. A가 B에게 잘 받았다고 B가 생성한 N2를 재 전송한다.(**상호인증**)  
(A->B) E(PU_{b}, N2)  

이 프로토콜은 확인할 때 마다 TimeStamp를 변경하면서 계속해서 요청하는 방식이기 때문에 **병목현상**을 일으킬 수 있다.

### Public-Key Certificates

확인하는 기관에서 인증서 자체를 줘 버리는 방식.  
인증서 = {신원, 공개키}를 기관이 서명해 주는 방식.  
자세한 내용은 아래에서 다루겠다.


### Simple Secret Key Distribution(Ks분배)

Merkle에 의해 고안된 방식이다.  
암호화 없이 공개키와 신원을 보내면, 그 공개키를 받은 사람이 Ks를 주는 방식.
   
(A->B) [ PU_{a} || ID_{A} ]  
(B->A) E(PU_{a}, Ks)

딱! 봐도 알겠지만, A->B 보내는 도중에 다른 사람이 낚아채는 위험이 있다.  
**Man-in-the-Middle-Attack**

(A->Z) [ PU_{a} || ID_{A} ]  
(Z->B) [ PU_{z] || IA_{A} ] // 이 과정에서 A인척 자신의 공개키를 준다.  
(B->Z) E(PU_{z}, Ks)  
(Z->A) E(PU_{a}, Ks)  

이렇게 되면 A, B는 각각 메시지를 정상적으로 받지만 3명이 Ks를 분배하는 결과를 낳게 된다.

### Secret-Key Distribution with Confidentiality & Authentication

각각 상대의 공개키로 암호화한 메시지를 보내고, 메시지에는 Nonce가 포함된다!!

(A->B) E(PU_{b}, [N1 || ID_{A}])  
(B->A) E(PU_{a}, [N1 || N2])  
(A->B) E(PU_{b}, N2)  
(A->B) E(PU_{b}, E(PR_{a}, Ks))

마지막 과정에서 Ks를 A가 자신의 비밀키로 서명하여, Man-in-the-Middle-Attack을 방지한다.  
마지막 과정에서 PU_{b}로 암호화 하는 것은 **기밀성**방지, PR_{a}로 암호화 하는 것은 **서명(인증)**을 위함!! 

### Hybrid Key Distribution

자세히 안다룬내용.

## ★ Diffie-Hellman Key Exchange

암호 Key(Session key)를 교환하는 하나의 방법.  
Discrete Logarithm Problem 기반 프로토콜.  

**사용 변수**  
	(공개) 큰 소수 *p*  
	(공개) 임의의 수 *g* (Generalization)  
	(비밀) A가 만드는 임의의 수 *a(YA)*  
	(비밀) B가 만드는 임의의 수 *b(YB)*  
	(비밀) a, b(YA, YB)로 계산할 수 있는 Secret key *S*

**교환하는 과정**

1. A와 B는 소수 **p**, 임의의 generalization **g**를 사용하기로 한다.  
	이해를 돕기 위해, p = 23, g = 5로 가정한다.

2. A가 임의의 수 a = 6을 선택한 후, YA를 B에게 전송한다. (YA = g^{a} mod p)  
	(A->B) YA.

3. B는 임의의 수 b = 15를 선택한 후, YB를 A에게 전송한다. (YB = g^{b} mod p)  
	(B->A) YB.

4. A, B는 각각 받은 수 YA, YB를 통해 Secret Key를 계산한다.  
	(**S** = **YA^{b} mod p** = **YB^{a} mod p**)

5. A와 B는 각각 Secret Key **S**를 공유하게 되었다.

단, 디피헬만 키분배는 **인증 과정이 없기 때문에** Man-in-the-Middle-Attack에 취약하다.  
(교환 알고리즘 자체는 암호학적으로 안정적임)

이 중간자 공격을 막기 위해 디피헬만 알고리즘 위에 다른 알고리즘을 섞어 사용한다.

## ElGamal Cryptography

Discrete Logarithm Problem 기반.  

엘가말 기반이라 엘가말 키 교환이랑 비슷함!!  

### 키 생성

1. 큰 소수 q를 선택하고, 생성자 g를 선택한다.  
2. 비밀키 x를 선택하고, 공개키 y를 계산한다.  
   (y = g^{x} mod q)  
3. {y, g, q}는 공개키, {x}는 비밀키가 된다.

### 메세지 암호화

1. 메세지 M을 암호화하기 위해 난수 k를 선택한다. (**일회성**)  
2. 난수 k로 One-Time Key인 K를 계산한다.  
   (K = y^{k} mod q)  
   (K는 풀어보면 g^{x * k} mod q가 된다)  
3. 암호문을 계산한다.  
   C1 = g^{k} mod q  
   C2 = K * M mod q  
4. (C1, C2)를 수신자에게 전달한다.

### 메세지 복호화

서로 미리 교환한 x값과 전달받은 C1, C2 값으로 받은 메세지를 복호화 해보자.  

1. One-Time-Key K를 C1을 통해 복호화한다.  
K = y^{k} mod q  
  = a^{k*x} mod q  
  = **C1^{x} mod q**

2. Message M을 C2와 계산한 K를 통해 복호화한다.  
M = C2 * K^{-1} mod q  
(K의 inverse 계산)

### 엘가말의 뽀인뜨

* 장점  
> 매 교환시 난수 k를 이용하므로 안전하다.  
> (같은 M, 같은 키를 사용해도 암호화 할때마다 변하기 때문)

* 단점  
> Message M을 암호화 할 때, 길이가 두 배로 늘어난다....(흑흑)

---

# CH10.2 ECC (Elliptic Curve Cryptography)

딴거 먼저 하고 이거 공부할 예정 ㅠㅠ

---  

# CH11 MAC & Hash

## 개요

메세지에 대한 인증(Message Athentication)은 크게 두 가지로 나뉜다.  
1) 보낸 메세지가 위조/변조되지 않았는가? 
2) 발신자에 대한 신원 확인(A가 맞는가?)  
3) 부정 방지(해 놓고 안했다 하기 없기)  

위 내용을 방지하기 위해 세 가지 function을 사용할 것이다.  
1. Message Encryption  
2. Message Authentication Code(MAC)  
3. hash function  

## Message Encryption

*Problem of public-key*  
public-key encryption을 사용하게 되면 **발신자에 대한 신원확인**이 어렵게 된다.(모두가 공개키를 알 수 있기 때문)  

*Solution*  
> 발신자가 메시지를 자신의 Private-key로 서명.  
> **비밀보장** 및 **인증**이 동시에 해결!!  

*But*  
암호화 하는데 비용이 들더라..  

## Message Authentication Code(MAC)

MAC은 메세지의 무결성 확인 및 인증을 위한 Code를 달아주는 방식이다.

**Sender**

....*input*  
Message, K(공유하는 key)  

....*전송하는 정보*  
Message와 MAC Code  

**Receiver**  

1. 메세지를 일단 받는다.  
2. 메세지를 같은 K값으로 MAC Algorithm을 거쳐 MAC Code를 얻는다.  
3. 받은 MAC과 일치하는지 확인한다.  

그림으로 이해하면 아래와 같다.  
![Message_Authentication_Code](https://zemalee.github.io/images/Computer_Security/01_Message_Athentication_Code.png)  

....*참고*  
MAC은 기본적으로 Many-to-One 함수이기 때문에, 같은 결과를 내는 입력이 여러개일 수 있다.  
따라서, MAC 알고리즘은 동일한 MAC값을 가진 Message를 찾는 것이 infeasible 해야 한다.   

MAC기반 DES-CBC 대표적인 알고리즘  
(**DAA**: Data Authentication Algorithm)  
Block-Chaining 방식 예제라네요..  
MAC이랑 연관됐는진 모르겠지만 눈에 익히기 위해...   
![Data Authentication Algorithm](https://zemalee.github.io/images/Computer_Security/02_Data_Authentication_Algorithm.png)  


## Hash Function

h = Hash( M )이라고 가정하고, MAC과 비슷한 동작을 함.  

A가 자기 private-key로 서명한 Hash 내용을 메세지에 붙여 전송하는 그림.  
![Hashing](https://zemalee.github.io/images/Computer_Security/03_Hashing.png)  

MAC과 비슷하게, 수신자도 Hash(M)을 한 번 수행하면 된다. 

*참고사항*  
h = H(x)라고 할 때,  
같은 h값을 갖는 x값이 여러개일 수 있기 때문에 보낸 진짜 내용을 찾기가 어렵다. 이를 One-way-function이라고 부른다.  
Collision이 일어날 확률이 매우 적다.  
(H(x)=H(y)가 될 확률이 적다)  
반대로 생각하면, 같은 해쉬값을 갖는 M을 찾기 힘들다.  

**요약**) M으로 h를 만들기는 쉽지만 h로 M을 찾기 어렵게 하는, 짧게 만들어 주는 해쉬함수!  

## Security of Hash Functions & MACs

**Birthday Paradox**  
Hash 충돌과 관련된 내용.  
365일 중, 같은 생일을 가진사람을 뽑을 확률이 23명이면 50%, 80명이면 거의 100% 뽑는다는 내용.  

결론만 적도록 하겠다.
Hash가 n bit라고 할 때, 1.17 * 루트 n을 취한만큼만 시도하면 충돌이 일어날 확률이 50%더라...  

---  

# CH12 MIC & SHA

## Classification of Hash Functions

MAC이라는 단어를 네트워크에서 하도 많이써서;;; 용어를 정리하도록 한다.  

Hash 함수를 목적에 따라 나눌 수 있다.  

* **MDC** = **MIC**  
수정여부를 검사하는 Code를 갖는 Hash.  
(MDC : Modification Detection Codes)  
(MIC : Message Integrity Codes)  
Key가 필요없다. **Unkeyed**  
같은 알고리즘을 사용하면 **같은 입력에 대해 항상 같은 출력을 갖는다.**  


```  
(농담)  
M : 모디파이 됐는지~  
D : 디텍션하는  
C : 코드  
```  

* **MAC**  
인증을 위한 Code를 갖는 Hash.
(MAC : Message Authentication Codes)  
Key가 항상 있어야 한다. **Keyed**  
같은 알고리즘을 사용해도 **Key에 따라 출력이 달라진다.**  

## UnKeyed Hash Functions - SHA

SHA : Secure Hash Algorithm  
160비트짜리를 SHA-1이라고 부른다.  
중국인 여자 교수 WANG이 치명적 단점을 밝힌 그 알고리즘..  

이후, SHA-256, 384, 512를 개발함.  

SHA-512만 간단하게 요약해보겠다.  
1. 메세지 Panding  
	메세지 길이를 1024의 배수로 맞추기 위해 Pending한다.  
2. 길이 정보 추가  
3. 해쉬 버퍼 초기화  
4. 1024 비트 처리  
5. 출력  

어려우니 그림으로 보자

![Message Pending](https://zemalee.github.io/images/Computer_Security/04_SHA1024_01.png)  

우선, 메세지 길이를 1024비트에 맞게 Pending.  
Initial Vector로 F함수를 처리할거다.  

![Message Pending](https://zemalee.github.io/images/Computer_Security/04_SHA1024_02.png)  

512비트 80개로 쪼개서 각 라운드를 진행한다.  

![Message Pending](https://zemalee.github.io/images/Computer_Security/04_SHA1024_03.png)  

각 라운드는 덧셈연산과 Major연산으로 빠르게 처리한다.  

다 외우거나 할 필요는 없어보인다. 넘어간다.  

## Keyed Hash Function - HMAC

### 간단한 Keyed-Hash 정보들  

왜 Keyed가 필요한가? = 인증에 이용하기 위함.  

간단하게 생각해보면  
Keyed Hash = Hash( Key | Message ).  

이런식으로 concat하면 공격자는 Message를 바꿔가면서 hash가 어떻게 출력되는지 Model이 깔끔하게 나와버린다.  
즉, Hash의 안전도만 남고 Keyed가 의미가 없어질 우려가 있다.

### HMAC

간단하게 말하면, 계속 Key값을 넣어서 바꿔서 찾아내기 힘들게 하는 방법이다.  

![Message Pending](https://zemalee.github.io/images/Computer_Security/05_HMAC_overview.png)  

Key를 input-padding한 값(초기값)을 넣고 돌린다.  
그 후, output을 또 Pending해서 넣는다.  
그 결과, **Key값과 출력이 직접적으로 연관이 없게 된다**  

이 또한 **외울 필요가 없다고 한다**.  

---  

# CH13 Digital Signature

ㅇ

---  

# CH14 Authentication X509 Certificate



---  

# CH15 User Authentication



---  

# CH19 ComputerSecurity MaliciousSW