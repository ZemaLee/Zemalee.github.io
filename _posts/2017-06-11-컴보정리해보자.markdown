---
layout: entry
title: "컴퓨터보안 시험용 정리"
author: 이제언
date: 2017-06-11 17:05 +0900
tags: 컴퓨터보안, 보안, 기말고사
comments: true
--- 
* table of contents
{:toc}

# RSA

## Review

일반적으로 암호화 할 때, sender, receiver가 같은 key를 공유했었다.

이렇게 되면, 두 사람이 key를 분배하는 과정에서 n명이 각각 서로 카톡방(?)을 가져야 하기 때문에 **nC2** 개 만큼 key가 필요했다.

그래서, **공개키 알고리즘**을 사용하기로 한다.



1. 두 소수 p, q를 선정한다.  
2. p, q를 통해 n = p x q라는 값을 갖게된다.  
3. phi(n) = (p-1) x (q-1) 값을 갖는다.  
4. gcd( e, phi(n) ) = 1인 e 값을 선정하여 공개키로 설정한다.  
5. d x e = 1 (mod phi(n))인 d를 구한다.

위 과정을 통해 PU = {e, n}, PR = {p, q, d}가 설정된다.

### 메세지 암호화, 복호화  
CipherText = Message^{e} mod n.  
공개키 e, n을 통해 아무 메시지나 암호화해서 보낼 수 있다.  

Message = CiperText^{d} mod n.  
비밀키 d를 통해 비밀 메시지를 풀 수 있다.



## 키 분배(관리)

키 분배(관리)에는 4가지 방법이 있다.

### Public Announcement  
그냥 다른 사람들에게 자신의 key를 알리는 방법이다.  
위조에 취약함.(ex. 저 제언인데요, 100만원만 빌려주세요^^)

### Public Available Directory  
게시판 같은 열린 공간에 자신의 공개키를 올리는 방법이다.  
이 방법은 홈페이지가 공격당하면 GG...

### Public-key Authority  
Public-key Authority(기관)이 공개키를 관리해주는 방식이다.  
A와 B가 통신하기 위해 아래의 과정을 거쳐야한다.

1. A가 기관에게 B의 공개키를 요구한다.  
(A->PA) Request || TimeStamp1  
2. 기관이 A에게 공개키를 서명해서 준다.  
(PA->A) E(PR_{auth} [ PU_{b} || Request || TimeStamp1 ])

3. A가 B의 공개키로 자신의 아이디와 Nonce를 실어 보낸다.  
(A->B) E(PU_{b}, [ID_{A} || Nonce1])

4. B도 기관에게 1, 2의 과정을 거쳐 A의 공개키를 얻는다.(식 생략)

5. B가 A의 공개키로 받은 Nonce와 새로운 Nonce를 생성하여 보낸다.
(B->A) E(PU_{a}, [N1 || N2])  
이 과정에서 B의 공개키로 암호화 된 N1을 해독하고 다시 보내주는 과정을 통해 **상호 인증**이 된다.

6. A가 B에게 잘 받았다고 B가 생성한 N2를 재 전송한다.(**상호인증**)  
(A->B) E(PU_{b}, N2)  

이 프로토콜은 확인할 때 마다 TimeStamp를 변경하면서 계속해서 요청하는 방식이기 때문에 **병목현상**을 일으킬 수 있다.

### Public-Key Certificates

확인하는 기관에서 인증서 자체를 줘 버리는 방식.  
인증서 = {신원, 공개키}를 기관이 서명해 주는 방식.  
자세한 내용은 아래에서 다루겠다.


### Simple Secret Key Distribution(Ks분배)

Merkle에 의해 고안된 방식이다.  
암호화 없이 공개키와 신원을 보내면, 그 공개키를 받은 사람이 Ks를 주는 방식.
   
(A->B) [ PU_{a} || ID_{A} ]  
(B->A) E(PU_{a}, Ks)

딱! 봐도 알겠지만, A->B 보내는 도중에 다른 사람이 낚아채는 위험이 있다.  
**Man-in-the-Middle-Attack**

(A->Z) [ PU_{a} || ID_{A} ]  
(Z->B) [ PU_{z] || IA_{A} ] // 이 과정에서 A인척 자신의 공개키를 준다.  
(B->Z) E(PU_{z}, Ks)  
(Z->A) E(PU_{a}, Ks)  

이렇게 되면 A, B는 각각 메시지를 정상적으로 받지만 3명이 Ks를 분배하는 결과를 낳게 된다.

### Secret-Key Distribution with Confidentiality & Authentication

각각 상대의 공개키로 암호화한 메시지를 보내고, 메시지에는 Nonce가 포함된다!!

(A->B) E(PU_{b}, [N1 || ID_{A}])  
(B->A) E(PU_{a}, [N1 || N2])  
(A->B) E(PU_{b}, N2)  
(A->B) E(PU_{b}, E(PR_{a}, Ks))

마지막 과정에서 Ks를 A가 자신의 비밀키로 서명하여, Man-in-the-Middle-Attack을 방지한다.  
마지막 과정에서 PU_{b}로 암호화 하는 것은 **기밀성**방지, PR_{a}로 암호화 하는 것은 **서명(인증)**을 위함!! 

### Hybrid Key Distribution

자세히 안다룬내용.

## ★ Diffie-Hellman Key Exchange

암호 Key(Session key)를 교환하는 하나의 방법.  
Discrete Logarithm Problem 기반 프로토콜.  

**사용 변수**  
	(공개) 큰 소수 *p*  
	(공개) 임의의 수 *g* (Generalization)  
	(비밀) A가 만드는 임의의 수 *a(YA)*  
	(비밀) B가 만드는 임의의 수 *b(YB)*  
	(비밀) a, b(YA, YB)로 계산할 수 있는 Secret key *S*

**교환하는 과정**

1. A와 B는 소수 **p**, 임의의 generalization **g**를 사용하기로 한다.  
	이해를 돕기 위해, p = 23, g = 5로 가정한다.

2. A가 임의의 수 a = 6을 선택한 후, YA를 B에게 전송한다. (YA = g^{a} mod p)  
	(A->B) YA.

3. B는 임의의 수 b = 15를 선택한 후, YB를 A에게 전송한다. (YB = g^{b} mod p)  
	(B->A) YB.

4. A, B는 각각 받은 수 YA, YB를 통해 Secret Key를 계산한다.  
	(**S** = **YA^{b} mod p** = **YB^{a} mod p**)

5. A와 B는 각각 Secret Key **S**를 공유하게 되었다.

단, 디피헬만 키분배는 **인증 과정이 없기 때문에** Man-in-the-Middle-Attack에 취약하다.

이 중간자 공격을 막기 위해 디피헬만 알고리즘 위에 다른 알고리즘을 섞어 사용한다.

## ElGamal Cryptography

