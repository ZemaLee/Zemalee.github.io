---
layout: entry
title: "컴퓨터보안 시험용 정리"
author: 이제언
date: 2017-06-11 17:05 +0900
tags: 컴퓨터보안, 보안, 기말고사
comments: true
--- 
* table of contents
{:toc}

# CH10.1 Key Management other PKC

## RSA

### Review

일반적으로 암호화 할 때, sender, receiver가 같은 key를 공유했었다.

이렇게 되면, 두 사람이 key를 분배하는 과정에서 n명이 각각 서로 카톡방(?)을 가져야 하기 때문에 **nC2** 개 만큼 key가 필요했다.

그래서, **공개키 알고리즘**을 사용하기로 한다.



1. 두 소수 p, q를 선정한다.  
2. p, q를 통해 n = p x q라는 값을 갖게된다.  
3. phi(n) = (p-1) x (q-1) 값을 갖는다.  
4. gcd( e, phi(n) ) = 1인 e 값을 선정하여 공개키로 설정한다.  
5. d x e = 1 (mod phi(n))인 d를 구한다.

위 과정을 통해 PU = {e, n}, PR = {p, q, d}가 설정된다.

### 메세지 암호화, 복호화  
CipherText = Message^{e} mod n.  
공개키 e, n을 통해 아무 메시지나 암호화해서 보낼 수 있다.  

Message = CiperText^{d} mod n.  
비밀키 d를 통해 비밀 메시지를 풀 수 있다.



## 키 분배(관리)

키 분배(관리)에는 4가지 방법이 있다.

### Public Announcement  
그냥 다른 사람들에게 자신의 key를 알리는 방법이다.  
위조에 취약함.(ex. 저 제언인데요, 100만원만 빌려주세요^^)

### Public Available Directory  
게시판 같은 열린 공간에 자신의 공개키를 올리는 방법이다.  
이 방법은 홈페이지가 공격당하면 GG...

### Public-key Authority  
Public-key Authority(기관)이 공개키를 관리해주는 방식이다.  
A와 B가 통신하기 위해 아래의 과정을 거쳐야한다.

1. A가 기관에게 B의 공개키를 요구한다.  
(A->PA) Request || TimeStamp1  
2. 기관이 A에게 공개키를 서명해서 준다.  
(PA->A) E(PR_{auth} [ PU_{b} || Request || TimeStamp1 ])

3. A가 B의 공개키로 자신의 아이디와 Nonce를 실어 보낸다.  
(A->B) E(PU_{b}, [ID_{A} || Nonce1])

4. B도 기관에게 1, 2의 과정을 거쳐 A의 공개키를 얻는다.(식 생략)

5. B가 A의 공개키로 받은 Nonce와 새로운 Nonce를 생성하여 보낸다.
(B->A) E(PU_{a}, [N1 || N2])  
이 과정에서 B의 공개키로 암호화 된 N1을 해독하고 다시 보내주는 과정을 통해 **상호 인증**이 된다.

6. A가 B에게 잘 받았다고 B가 생성한 N2를 재 전송한다.(**상호인증**)  
(A->B) E(PU_{b}, N2)  

이 프로토콜은 확인할 때 마다 TimeStamp를 변경하면서 계속해서 요청하는 방식이기 때문에 **병목현상**을 일으킬 수 있다.

### Public-Key Certificates

확인하는 기관에서 인증서 자체를 줘 버리는 방식.  
인증서 = {신원, 공개키}를 기관이 서명해 주는 방식.  
자세한 내용은 아래에서 다루겠다.


### Simple Secret Key Distribution(Ks분배)

Merkle에 의해 고안된 방식이다.  
암호화 없이 공개키와 신원을 보내면, 그 공개키를 받은 사람이 Ks를 주는 방식.
   
(A->B) [ PU_{a} || ID_{A} ]  
(B->A) E(PU_{a}, Ks)

딱! 봐도 알겠지만, A->B 보내는 도중에 다른 사람이 낚아채는 위험이 있다.  
**Man-in-the-Middle-Attack**

(A->Z) [ PU_{a} || ID_{A} ]  
(Z->B) [ PU_{z] || IA_{A} ] // 이 과정에서 A인척 자신의 공개키를 준다.  
(B->Z) E(PU_{z}, Ks)  
(Z->A) E(PU_{a}, Ks)  

이렇게 되면 A, B는 각각 메시지를 정상적으로 받지만 3명이 Ks를 분배하는 결과를 낳게 된다.

### Secret-Key Distribution with Confidentiality & Authentication

각각 상대의 공개키로 암호화한 메시지를 보내고, 메시지에는 Nonce가 포함된다!!

(A->B) E(PU_{b}, [N1 || ID_{A}])  
(B->A) E(PU_{a}, [N1 || N2])  
(A->B) E(PU_{b}, N2)  
(A->B) E(PU_{b}, E(PR_{a}, Ks))

마지막 과정에서 Ks를 A가 자신의 비밀키로 서명하여, Man-in-the-Middle-Attack을 방지한다.  
마지막 과정에서 PU_{b}로 암호화 하는 것은 **기밀성**방지, PR_{a}로 암호화 하는 것은 **서명(인증)**을 위함!! 

### Hybrid Key Distribution

자세히 안다룬내용.

## ★ Diffie-Hellman Key Exchange

암호 Key(Session key)를 교환하는 하나의 방법.  
Discrete Logarithm Problem 기반 프로토콜.  

**사용 변수**  
	(공개) 큰 소수 *p*  
	(공개) 임의의 수 *g* (Generalization)  
	(비밀) A가 만드는 임의의 수 *a(YA)*  
	(비밀) B가 만드는 임의의 수 *b(YB)*  
	(비밀) a, b(YA, YB)로 계산할 수 있는 Secret key *S*

**교환하는 과정**

1. A와 B는 소수 **p**, 임의의 generalization **g**를 사용하기로 한다.  
	이해를 돕기 위해, p = 23, g = 5로 가정한다.

2. A가 임의의 수 a = 6을 선택한 후, YA를 B에게 전송한다. (YA = g^{a} mod p)  
	(A->B) YA.

3. B는 임의의 수 b = 15를 선택한 후, YB를 A에게 전송한다. (YB = g^{b} mod p)  
	(B->A) YB.

4. A, B는 각각 받은 수 YA, YB를 통해 Secret Key를 계산한다.  
	(**S** = **YA^{b} mod p** = **YB^{a} mod p**)

5. A와 B는 각각 Secret Key **S**를 공유하게 되었다.

단, 디피헬만 키분배는 **인증 과정이 없기 때문에** Man-in-the-Middle-Attack에 취약하다.  
(교환 알고리즘 자체는 암호학적으로 안정적임)

이 중간자 공격을 막기 위해 디피헬만 알고리즘 위에 다른 알고리즘을 섞어 사용한다.

## ElGamal Cryptography

Discrete Logarithm Problem 기반.  

엘가말 기반이라 엘가말 키 교환이랑 비슷함!!  

### 키 생성

1. 큰 소수 q를 선택하고, 생성자 g를 선택한다.  
2. 비밀키 x를 선택하고, 공개키 y를 계산한다.  
   (y = g^{x} mod q)  
3. {y, g, q}는 공개키, {x}는 비밀키가 된다.

### 메세지 암호화

1. 메세지 M을 암호화하기 위해 난수 k를 선택한다. (**일회성**)  
2. 난수 k로 One-Time Key인 K를 계산한다.  
   (K = y^{k} mod q)  
   (K는 풀어보면 g^{x * k} mod q가 된다)  
3. 암호문을 계산한다.  
   C1 = g^{k} mod q  
   C2 = K * M mod q  
4. (C1, C2)를 수신자에게 전달한다.

### 메세지 복호화

서로 미리 교환한 x값과 전달받은 C1, C2 값으로 받은 메세지를 복호화 해보자.  

1. One-Time-Key K를 C1을 통해 복호화한다.  
K = y^{k} mod q  
  = a^{k*x} mod q  
  = **C1^{x} mod q**

2. Message M을 C2와 계산한 K를 통해 복호화한다.  
M = C2 * K^{-1} mod q  
(K의 inverse 계산)

### 엘가말의 뽀인뜨

* 장점  
> 매 교환시 난수 k를 이용하므로 안전하다.  
> (같은 M, 같은 키를 사용해도 암호화 할때마다 변하기 때문)

* 단점  
> Message M을 암호화 할 때, 길이가 두 배로 늘어난다....(흑흑)

---

# CH10.2 ECC (Elliptic Curve Cryptography)

딴거 먼저 하고 이거 공부할 예정 ㅠㅠ

# CH11 MAC & Hash

## 개요

메세지에 대한 인증(Message Athentication)은 크게 두 가지로 나뉜다.  
1) 보낸 메세지가 위조/변조되지 않았는가? 
2) 발신자에 대한 신원 확인(A가 맞는가?)  
3) 부정 방지(해 놓고 안했다 하기 없기)  

위 내용을 방지하기 위해 세 가지 function을 사용할 것이다.  
1. Message Encryption  
2. Message Authentication Code(MAC)  
3. hash function  

## Message Encryption

*Problem of public-key*  
public-key encryption을 사용하게 되면 **발신자에 대한 신원확인**이 어렵게 된다.(모두가 공개키를 알 수 있기 때문)  

*Solution*  
> 발신자는 메시지에 자신의 Private-key로 서명하여 **비밀**보장 및 **인증**과정이 동시에 수행될 수 있게 한다.  

*But*  
암호화 하는데 비용이 들더라..  

## Message Authentication Code(MAC)

그림을 먼저 보고 시작하도록 하자.  
![Message Authentication Code](/images/Computer_Security/01_Message_Athentication_Code.PNG)  

# CH12 MIC SHA

# CH13 Digital Signature

# CH14 Authentication X509 Certificate

# CH15 User Authentication

# CH19 ComputerSecurity MaliciousSW