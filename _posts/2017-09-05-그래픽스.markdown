---
layout: entry
title: "그래픽스 - 이도훈"
author: 이제언
date: 2017-09-05 10:30 +0900
tags: 그래픽스, 전공
comments: true
--- 
* table of contents	
{:toc}

# OT

주교재 : 주우석 - OpenGL로 배우는 컴퓨터 그래픽스, 한빛미디어

|   채점사항   |  %  |
|:-----------:|----:|
|   중간고사   | 30% |
|   기말고사   | 35% |
|    과  제    | 30% |
|  태도 및 기타 | 5% |

단, 별도의 연락 없이 중간/기말 불참시 학점 X

모든 과제는 워드 사용 없이 필기하여 제출.

PyOpenGL, OpenGL, JS 등등 사용할 예정

# 교수님의 의식의 흐름 기법(수업 적다 포기)

WYSWYG : What You See, What You Get.

* 모델링(Modeling)  
   장면 내부 물체를 정의하는 작업  
   선분의 끝점, 다각형의 정점을 정의

* 렌더링(Rendering)  
   정의될 물체를 그려내기  
   와이어 프레임 렌더링, 솔리드 렌더링...

# Graphic Hardware

(그냥 적음)사각형 그리는 예제 - 일반코드?  
```  
v 4 e 4  
1 1  
1 2  
2 2  
2 1  
1 2  
2 3  
3 4  
4 1  
```

사각형 그리기 예제 - Python OpenGL  
```python  
def MyDisplay() :  
..glClear(GL_COLOR_BUFFER_BIT)  
..glBegin(GL_POLYGON)  
..glVertex3f(1.0, 1.0, 0.0)  
..glVertex3f(1.0, 2.0, 0.0)  
..glVertex3f(2.0, 2.0, 0.0)  
..glVertex3f(2.0, 1.0, 0.0)  
..glEnd()  
..glFlush()  

def main() :  
..glutInit()  
..glutCreateWindow(b"OpenGL Drawing Example")  
..glutDisplayFunc(MyDisplay)  
..glutMainLoop()

if __name__ == '__main__' :  
  main()  
```

(픽셀 계산, 용량 계산 할줄모르겠음...)

## 래스터 그래픽 장치(유한 해상도)

화면이 **화소**라는 단위로 구성된 모니터를 위미한다. 화소는 R, G, B의 색을 가지는 점으로 이루어지고, 화소의 색상은 이 세가지 점의 밝기를 합쳐서 계산된다.  
해상도는 **화소 수에 의해 결정**된다.  
**인터레이싱** : 홀/짝으로 나눠 절반씩 주사함(깜빡거림 감소, 빠르게 보여줄 수 있음)  
모니터에 줄 나오는 것을 **Alias**라고 부른다.  
래스터 장치의 화면 그림은 **프레임 버퍼**에 저장된다.  
화소의 밝기를 조절하는 회로를 **DA 변환기**라 한다.  
N개의 비트평면을 가진 프레임 버퍼는 2의 N승만큼의 색을 표현할 수 있다.

**그림그리는거 무거움, 각 색깔 색연필 있음**

## 벡터 그래픽 장치(무한 해상도)

벡터 그래픽 장치에는 **화소**개념이 없다. 찍는 인두를 조절하면서 점만 찍으면 되기 때문에 매우 작은 메모리를 요구한다. 좋으면 뭐다? **구현 속도가 느리다**

**그림그리기 쉬움, 쎄게누르면R, 살살누르면 G, B..이런느낌?** (용어로는 **빔 투과 방식**)

![래스터 벡터디스플레이 차이](https://zemalee.github.io/images/201702/graphics1.png)

## 모니터?

**CRT** : TV모니터와 같은 방식. 전기가 부딪혀서 에너지를 발생시켜 그림을 표현

**LCD** : 픽셀단위로 나누긴하지만, 전기총 안씀. cell array를 교체하면서 보여준다(?) - 해석불가  
전압조절로 Grey Level(R,G,B값)을 조절함.

![LCD, CRT 차이](https://zemalee.github.io/images/201702/graphics0.png)

**기타**  
![LCD, 플라즈마, LED](https://zemalee.github.io/images/201702/graphics2.png)

# Color Model

## 색상, 명도, 채도

**색상** : 물체에서 반사된 빛 중 가장 많은 에너지를 지닌 파장의 주파수의 색상.  
**채도** : 색상 에너지와 백색 에너지의 차이. 색상의 주파수를 높이거나 백색 에너지를 낮추면 채도가 높아진다.(채도가 높다 : 짙어진다)  
**명도** : 빛 에너지의 총량

**컬러 매칭**  
결과적인 파장이 다르더라도 사람 눈에는 동일한 색으로 보일 수 있는 현상  
(+) 색온도 : 태양, 백열등에서 나오는 빛의 색상을 흑체의 온도로 표시한 것.

## 컬러모델

**RGB 컬러모델(Red Green Blue)**  
  R,G,B를 각각 x,y,z축에 갖다놓고 가중치에 따라 색을 정의하고자 하는 가산모델. 모두 더하여 다른 색을 만든다.

**CMY 컬러모델(Cyan Magenta Yello)**  
  물감의 삼원색이래요.  
  RGB의 보색으로 (Magenta, Yello, Cyan).  
  주로 인쇄장비에 사용하고 감산모델이다.  
  요즘은 확장해서 CMYK(K:회색농도)를 쓴다.  
(CMYK장점 : 잉크건조시간, 잉크비용, 정밀한 회색농도 표현)

**HSV 컬러모델(Hue, Saturation, Value_Color_Model**  
RGB모델의 단점인 "직관적이지 않다"를 보완?  
색을 색상, 명도, 채도를 이용하여 표기하는 방법.  
(틴트 : 백색을 추가해 명도증가 채도감소하는 기법)

**YUV, YIQ**  
사람의 눈이 3원색이라도 각 색에 대해 다른 감도를 지님을 깨닫고 만듬

**CIE L\*a\*b과 컬러호환**  
웨버의 법칙에 기반한 인지 컬러모델.

## 컬러 모드

**RGB 컬러모드** : 프레임 버퍼의 내용이 색을 결정  
용량에 따라 색 종류가 결정된다.

**인덱스 컬러모드** : 컬러 번역기  
컬러보기표(CLUT:Color LookUp Table)를 보고 컬러보기표의 인덱스를 찾아서 그 색을 표현한다.  
컬러보기표의 크기에 따라 표현할 수 있는 색상은 이론적으로 훨씬 늘어나지만, 인덱스를 넣는 프레임버퍼의 크기에 제한될 수 밖에 없다.  
프레임버퍼의 크기는 한꺼번에 표현할 수 있는 색을 의미하게 된다.  
그림의 색조가 유사할때 효과적이다.  
PNG, BMP, TGA, TIFF 등의 확장자로 끝나면 인덱스 컬러모드를 지원한다.

## ★하프토우닝과 디더링

**★하프토우닝** : 우리 눈의 인식방법을 이용하여 직접적인 색의 변화가 아닌 점의 밀도로 명암을 표현하는 기법.  
디지털 하프토우닝은 인점의 크기를 변경할 수 없으므로, 밀도만을 이용해서 구현한다.  
하프토운 행렬이란, 화소를 선택하는 순서를 행렬로 표시한 것이다.  
패턴은 임의로 구성가능하지만, 규칙성이 없어야 한다는 점에 유의해야 한다.

**디더링** : 해상도를 동일하게 유지하며 , 근사화에 따른 시각적 오류를 최소화 한 것이다.
오류확산 알고리즘을 이용한 디더링, 패턴 행렬을 이용한 패턴 디더링이 있다. 두 방법 다 디더 잡음을 만들어 내는데, 이것은 시각적인 규칙성을 해상도의 감소없이 처리하는 방법이다.





# Computer Graphics API

## 표준화  

**정의** - 주어진 여건에서 최적의 질서를 유지하기 위해, 현존하거나 잠재하는 문제들에 대해, 공유성과 재사용성을 높이기 위한 기반을 확립하는 행위

**표준의 목표**  
* 주전산기 독립성 : 동일한 프로그램으로 모든 HW에서 사용 가능해야 함  
* 장비 독립성 : 입출력 장비의 종류가 달라도 프로그램 명령은 동일해야 한다.  
* 프로그램 언어 독립성 : 어떠한 프로그램 언어를 사용해도 된다.
* 운영자 이식성 : 새로운 프로그램 사용법을 쉽게 터득할 수 있어야 한다.

# 으앙 더 못적겠다 중요해보이는것만  

**오픈지엘 설계 원리**  
(1) 범용성 - OS나 H/W에 무관해야한다.  
(2) 효율성 - 가속기능을 최대한 발휘, 성능 극대화  
(3) 독립성 - 기능끼리 독립성 최대한 보장  
(4) 완전성 - 확장 형태 명령제공, 표준기능으로의 변경, SW라도 실행할 수 있도록 배려  
(5) 상호작업성 - 명령과 실행 분리(클라-서버모델) -> 성능이 낮은 클라이언트가 고성능 서버를 이용

  
