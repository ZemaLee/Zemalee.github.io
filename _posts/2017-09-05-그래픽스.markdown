---
layout: entry
title: "그래픽스 - 이도훈"
author: 이제언
date: 2017-09-05 10:30 +0900
tags: 그래픽스, 전공
comments: true
--- 
* table of contents	
{:toc}

# OT

주교재 : 주우석 - OpenGL로 배우는 컴퓨터 그래픽스, 한빛미디어

|   채점사항   |  %  |
|:-----------:|----:|
|   중간고사   | 30% |
|   기말고사   | 35% |
|    과  제    | 30% |
|  태도 및 기타 | 5% |

단, 별도의 연락 없이 중간/기말 불참시 학점 X

모든 과제는 워드 사용 없이 필기하여 제출.

PyOpenGL, OpenGL, JS 등등 사용할 예정

# 교수님의 의식의 흐름 기법(수업 적다 포기)

WYSWYG : What You See, What You Get.

* 모델링(Modeling)  
   장면 내부 물체를 정의하는 작업  
   선분의 끝점, 다각형의 정점을 정의

* 렌더링(Rendering)  
   정의될 물체를 그려내기  
   와이어 프레임 렌더링, 솔리드 렌더링...

# Graphic Hardware

(그냥 적음)사각형 그리는 예제 - 일반코드?  
```  
v 4 e 4  
1 1  
1 2  
2 2  
2 1  
1 2  
2 3  
3 4  
4 1  
```

사각형 그리기 예제 - Python OpenGL  
```python  
def MyDisplay() :  
..glClear(GL_COLOR_BUFFER_BIT)  
..glBegin(GL_POLYGON)  
..glVertex3f(1.0, 1.0, 0.0)  
..glVertex3f(1.0, 2.0, 0.0)  
..glVertex3f(2.0, 2.0, 0.0)  
..glVertex3f(2.0, 1.0, 0.0)  
..glEnd()  
..glFlush()  

def main() :  
..glutInit()  
..glutCreateWindow(b"OpenGL Drawing Example")  
..glutDisplayFunc(MyDisplay)  
..glutMainLoop()

if __name__ == '__main__' :  
  main()  
```

(픽셀 계산, 용량 계산 할줄모르겠음...)

## 래스터 그래픽 장치(유한 해상도)

화면이 **화소**라는 단위로 구성된 모니터를 위미한다. 화소는 R, G, B의 색을 가지는 점으로 이루어지고, 화소의 색상은 이 세가지 점의 밝기를 합쳐서 계산된다.  
해상도는 **화소 수에 의해 결정**된다.  
**인터레이싱** : 홀/짝으로 나눠 절반씩 주사함(깜빡거림 감소, 빠르게 보여줄 수 있음)  
모니터에 줄 나오는 것을 **Alias**라고 부른다.  
래스터 장치의 화면 그림은 **프레임 버퍼**에 저장된다.  
화소의 밝기를 조절하는 회로를 **DA 변환기**라 한다.  
N개의 비트평면을 가진 프레임 버퍼는 2의 N승만큼의 색을 표현할 수 있다.

**그림그리는거 무거움, 각 색깔 색연필 있음**

## 벡터 그래픽 장치(무한 해상도)

벡터 그래픽 장치에는 **화소**개념이 없다. 찍는 인두를 조절하면서 점만 찍으면 되기 때문에 매우 작은 메모리를 요구한다. 좋으면 뭐다? **구현 속도가 느리다**

**그림그리기 쉬움, 쎄게누르면R, 살살누르면 G, B..이런느낌?** (용어로는 **빔 투과 방식**)

![래스터 벡터디스플레이 차이](https://zemalee.github.io/images/201702/graphics1.png)

## 모니터?

**CRT** : TV모니터와 같은 방식. 전기가 부딪혀서 에너지를 발생시켜 그림을 표현

**LCD** : 픽셀단위로 나누긴하지만, 전기총 안씀. cell array를 교체하면서 보여준다(?) - 해석불가  
전압조절로 Grey Level(R,G,B값)을 조절함.

![LCD, CRT 차이](https://zemalee.github.io/images/201702/graphics0.png)

**기타**  
![LCD, 플라즈마, LED](https://zemalee.github.io/images/201702/graphics2.png)

# Color Model

## 색상, 명도, 채도

**색상** : 물체에서 반사된 빛 중 가장 많은 에너지를 지닌 파장의 주파수의 색상.  
**채도** : 색상 에너지와 백색 에너지의 차이. 색상의 주파수를 높이거나 백색 에너지를 낮추면 채도가 높아진다.(채도가 높다 : 짙어진다)  
**명도** : 빛 에너지의 총량

**컬러 매칭**  
결과적인 파장이 다르더라도 사람 눈에는 동일한 색으로 보일 수 있는 현상  
(+) 색온도 : 태양, 백열등에서 나오는 빛의 색상을 흑체의 온도로 표시한 것.

## 컬러모델

**RGB 컬러모델(Red Green Blue)**  
  R,G,B를 각각 x,y,z축에 갖다놓고 가중치에 따라 색을 정의하고자 하는 가산모델. 모두 더하여 다른 색을 만든다.

**CMY 컬러모델(Cyan Magenta Yello)**  
  물감의 삼원색이래요.  
  RGB의 보색으로 (Magenta, Yello, Cyan).  
  주로 인쇄장비에 사용하고 감산모델이다.  
  요즘은 확장해서 CMYK(K:회색농도)를 쓴다.  
(CMYK장점 : 잉크건조시간, 잉크비용, 정밀한 회색농도 표현)

**HSV 컬러모델(Hue, Saturation, Value_Color_Model**  
RGB모델의 단점인 "직관적이지 않다"를 보완?  
색을 색상, 명도, 채도를 이용하여 표기하는 방법.  
(틴트 : 백색을 추가해 명도증가 채도감소하는 기법)

**YUV, YIQ**  
사람의 눈이 3원색이라도 각 색에 대해 다른 감도를 지님을 깨닫고 만듬

**CIE L\*a\*b과 컬러호환**  
웨버의 법칙에 기반한 인지 컬러모델.

## 컬러 모드

**RGB 컬러모드** : 프레임 버퍼의 내용이 색을 결정  
용량에 따라 색 종류가 결정된다.

**인덱스 컬러모드** : 컬러 번역기  
컬러보기표(CLUT:Color LookUp Table)를 보고 컬러보기표의 인덱스를 찾아서 그 색을 표현한다.  
컬러보기표의 크기에 따라 표현할 수 있는 색상은 이론적으로 훨씬 늘어나지만, 인덱스를 넣는 프레임버퍼의 크기에 제한될 수 밖에 없다.  
프레임버퍼의 크기는 한꺼번에 표현할 수 있는 색을 의미하게 된다.  
그림의 색조가 유사할때 효과적이다.  
PNG, BMP, TGA, TIFF 등의 확장자로 끝나면 인덱스 컬러모드를 지원한다.

## ★하프토우닝과 디더링

**★하프토우닝** : 우리 눈의 인식방법을 이용하여 직접적인 색의 변화가 아닌 점의 밀도로 명암을 표현하는 기법.  
디지털 하프토우닝은 인점의 크기를 변경할 수 없으므로, 밀도만을 이용해서 구현한다.  
하프토운 행렬이란, 화소를 선택하는 순서를 행렬로 표시한 것이다.  
패턴은 임의로 구성가능하지만, 규칙성이 없어야 한다는 점에 유의해야 한다.

**디더링** : 해상도를 동일하게 유지하며 , 근사화에 따른 시각적 오류를 최소화 한 것이다.
오류확산 알고리즘을 이용한 디더링, 패턴 행렬을 이용한 패턴 디더링이 있다. 두 방법 다 디더 잡음을 만들어 내는데, 이것은 시각적인 규칙성을 해상도의 감소없이 처리하는 방법이다.





# Computer Graphics API

## 표준화  

**정의** - 주어진 여건에서 최적의 질서를 유지하기 위해, 현존하거나 잠재하는 문제들에 대해, 공유성과 재사용성을 높이기 위한 기반을 확립하는 행위

**표준의 목표**  
* 주전산기 독립성 : 동일한 프로그램으로 모든 HW에서 사용 가능해야 함  
* 장비 독립성 : 입출력 장비의 종류가 달라도 프로그램 명령은 동일해야 한다.  
* 프로그램 언어 독립성 : 어떠한 프로그램 언어를 사용해도 된다.
* 운영자 이식성 : 새로운 프로그램 사용법을 쉽게 터득할 수 있어야 한다.

# 으앙 더 못적겠다 중요해보이는것만  

**오픈지엘 설계 원리**  
(1) 범용성 - OS나 H/W에 무관해야한다.  
(2) 효율성 - 가속기능을 최대한 발휘, 성능 극대화  
(3) 독립성 - 기능끼리 독립성 최대한 보장  
(4) 완전성 - 확장 형태 명령제공, 표준기능으로의 변경, SW라도 실행할 수 있도록 배려  
(5) 상호작업성 - 명령과 실행 분리(클라-서버모델) -> 성능이 낮은 클라이언트가 고성능 서버를 이용

  
# 기말대비

## Projection(투상)

**투상** = **가시변환**

투상된 물체는 저 멀리 있겠지만, 실제 투상면에 비추어져 보임(각막에 그림이 얹히는 느낌)

### 평행투상

**이론**    
  시점이 물체로부터 무한히 멀리 있다고 가정  
  ~ 투상선이 평행하다  
  ~ 시점, 거리와 무관하게 실제 크기로 보임

### 원근투상
  
  시점이 물체로부터 유한한 거리에 있다고 가정  
  ~ 투상선이 시점으로부터 물에 돌던지 듯 퍼져나감  
  ~ 카메라, 사람의 눈이 실제로 포착하는 방법과 유사

## Vector

**정규화 벡터** : 벡터의 크기  
**벡터의 내적** : A * B = |A| |B| cos(?) 
**벡터의 외적** : A X B = |A| |B| sin(?) = 두 벡터가 이루는 도형의 넓이가 된다.

## Lighting & Shading

### Lighting

**조명 모델** : 광원, 물체면, 시점 등을 기준으로 어떤 빛의 성분들이 어느 정도 세기로 눈에 도달할 것인가?에 대한 방법론  
(1) 전역 조명모델 : 다른 물체의 빛까지 반사되는 빛까지 고려한 조명모델  
(2) 지역 조명모델 : 딱 자기색깔만 나타내는 조명모델

**빛의 방향에 따른 광원**  
(1) 위치성 광원  
: 옴니라이트, 빛이 한 점에서 방사형으로 퍼지는 것  
: 광원의 위치가 중요시 됨. 깜깜한 방 안의 촛불과 같은 느낌?
  
(2) 방향성 광원  
: 빛이 물체를 향해 일정한 방향으로 진행되는 것  
: 태양느낌(멀어서 수평으로 들어오는 느낌)

**일반적 조명 모델**  
(요약)  
(1) 주변광 - 180도 넘는데 빛이 있음  
(2) 확산광 - 뒤로갈수록 점점 어두워지는 현상  
(3) 경면광 - 광원이 반사됨(사과의 반질반질 느낌표)

**주변반사** : 광원의 위치에 상관 없이 모든 물체의 밝기를 일정 크기로 증가시키는 것.  
**확산반사** : 물체면과 광원의 위치관계에 따라 명암을 부여하는 것.(면 위치, 면방향 등에 따라 달라짐)  
**경면반사** : 반질반질한 표면에서 반사되는 빛.(광원의 색깔이 약간 반사되는 것?)

### Shading

(1) 플랫 Shading  
: 다각형의 중심만 조명을 계산해서 그 다각형 같은색으로 칠해버림  
: 마하밴드 효과(경계선이 보이는 현상)가 일어난다.  

(2) 구로 Shading  
: 플랫이랑 비슷한데 다각형 내부 색을 보간하는 방법.  
: 여전히 마하밴드 효과가 남아있다.

(3) 퐁 Shading  
: 다각형 색 대신 법선벡터를 보간.  
: 마하밴드 효과가 거의 일어나지 않음  
: 구로 셰이딩에 비해 3배정도 더 시간이 걸린다

(4) 블린 Shading  
(5) 금속 Shading(쿡, 토렌스)


## Rasterization

**Raster**란 정점, 선분, 면 등을 표현하기 위해 어떤 화소를 선택할 지 선택하는 방법.


