---
layout: entry
title: "소시설 시험대비 빠샤"
author: 이제언
date: 2017-06-17 00:19 +0900
tags: 소시설, 기말고사
comments: true
---
* table of contents
{:toc}

# 단위테스트

## JUnit 이용 Test  

**Assertion 유형**  
assertEquals(a, b);  
assertNull(object);  
assertNotNull(object);  
assertSame(a, b); // 같은 객체 참조여부  
assertNotSame(a, b);  
assertTrue(condition);  

**JUnit test 예시**  

```java  

public class MathTest {
    private Mymath testMath;
	
	@Test
	public void testConstructor() {
		testMath = new Mymath();
		assertTrue(testMath.getUseCount() == 0);
	}

	@Test
	public void testAddition() {
		assertEquals(5, testMath.addition(2, 3));
	}

	@Test
	public void testMultiply() {
		assertEquals(6, testMath.multiply(2, 3));
	}
}

```  

**경계값**을 고려하면서 test하자!  

## Mock Test  

**유용성**  
아직 완전히 만들어지지 않은 개체에 대한 테스트가 가능하다.

---  
---  

# Testing

## BlackBox Testing

### State Coverage  

![State Coverage Example](https://zemalee.github.io/images/Software_Engineering/01_State_Coverage.png)

### Transition Coverage

![Transition Coverage Example](https://zemalee.github.io/images/Software_Engineering/02_Transition_Coverage.png)

---  
---  

# Refactoring  

## Overview

Refactoring이란 외부에서 본 프로그램의 동작은 변하지 않고, 프로그램 내부의 구조를 개선하는 것이다.  
**"외부에서 본 동작은 변하지 않고** -> 최소한의 단위테스트는 필요.  

**Bad Smell 측정**  
* CC  
	Number of decisions + 1
	if, else, for loop가 많을 때 증가  
* Nesting Depth  
	Number of Structuring levels  
	중첩된 if의 깊이  
* NPath  
	Number of (static) Execution Paths  
	갈 수 있는 경로의 갯수  
* Coupling  
	Degree of interdependence beteween two modules  
* Cohesion  
	strength of functional relatedness of elements within a module  
* LOC  
	Lines of Code  

**SOLID 원칙**  

| SOLID |              해 설              |
|:-----:|:-------------------------------:|
|   S   | **S**ingle **R**esponsibility **P**rinciple |
|   O   |      **O**pen **C**losed **P**rinciple      |
|   L   |  **L**iskov **S**ubstitution **P**rinciple  |
|   I   | **I**nterface **S**egregation **P**rinciple |
|   D   |  **D**ependency **I**nversion **P**rinciple |


응집도 : S  
규모 : S  
복잡도 : D  
결합도 : L, I, D  

# Design Pattern

## Strategy Pattern

알고리즘군을 정의하고 각각을 캡슐화하여 교환할 수 있도록 만든다.  
전략패턴을 사용함으로써 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.

![Transition Coverage Example](https://zemalee.github.io/images/Software_Engineering/03_Strategy_Pattern.png)

**이점**  
코드 중복을 줄일 수 있다.  
신규 알고리즘 추가가 용이하다(확장성이 높다)  
알고리즘 변경에 용이하다.

**예시코드**  

*Strategy*  
```java  
public interface Statistics {  
	public int getMax(int[] data) ;  
	public int getMin(int[] data) ;  
	public float getAverage(int[] data) ;  
}  
```

*Context*  
```java  
public class ScoreProcessing { 
	private Statistics statistics ;  
	private int min, max ;  
	private float average ;  
	public ScoreProcessing(Statistics statistics) {  
		this.statistics = statistics;  
	}  
	public void analyze(int[] data) {  
		min = statistics.getMin(data);  
		max = statistics.getMax(data);  
		average = statistics.getAverage(data);  
	}  
	public int getMin() { return min; }  
	public int getMax() { return max; }  
	public float getAverage() { return average; }  
}  
```

*Concrete Strategies*  
```java  
public class GeneralStatistics implements Statistics {  
	public int getMax(int[] data) { /* 실제 내부 구현 */ }  
	public int getMin(int[] data) { /* 실제 내부 구현 */ }  
	public float getAverage(int[] data) { /* 실제 내부 구현 */ }  
}  
```  
 
## Observer Pattern

## Template Method Pattern

